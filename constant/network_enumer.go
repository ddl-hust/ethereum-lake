// Code generated by "enumer -type=Network -transform=snake -trimprefix=Network -json"; DO NOT EDIT.

package constant

import (
	"encoding/json"
	"fmt"
	"strings"
)

const (
	_NetworkName_0      = "ethereum"
	_NetworkLowerName_0 = "ethereum"
	_NetworkName_1      = "optimism"
	_NetworkLowerName_1 = "optimism"
	_NetworkName_2      = "bsc"
	_NetworkLowerName_2 = "bsc"
	_NetworkName_3      = "ethereum_classic"
	_NetworkLowerName_3 = "ethereum_classic"
	_NetworkName_4      = "polygon"
	_NetworkLowerName_4 = "polygon"
	_NetworkName_5      = "arbitrum_one"
	_NetworkLowerName_5 = "arbitrum_one"
)

var (
	_NetworkIndex_0 = [...]uint8{0, 8}
	_NetworkIndex_1 = [...]uint8{0, 8}
	_NetworkIndex_2 = [...]uint8{0, 3}
	_NetworkIndex_3 = [...]uint8{0, 16}
	_NetworkIndex_4 = [...]uint8{0, 7}
	_NetworkIndex_5 = [...]uint8{0, 12}
)

func (i Network) String() string {
	switch {
	case i == 1:
		return _NetworkName_0
	case i == 10:
		return _NetworkName_1
	case i == 56:
		return _NetworkName_2
	case i == 61:
		return _NetworkName_3
	case i == 137:
		return _NetworkName_4
	case i == 42161:
		return _NetworkName_5
	default:
		return fmt.Sprintf("Network(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NetworkNoOp() {
	var x [1]struct{}
	_ = x[NetworkEthereum-(1)]
	_ = x[NetworkOptimism-(10)]
	_ = x[NetworkBSC-(56)]
	_ = x[NetworkEthereumClassic-(61)]
	_ = x[NetworkPolygon-(137)]
	_ = x[NetworkArbitrumOne-(42161)]
}

var _NetworkValues = []Network{NetworkEthereum, NetworkOptimism, NetworkBSC, NetworkEthereumClassic, NetworkPolygon, NetworkArbitrumOne}

var _NetworkNameToValueMap = map[string]Network{
	_NetworkName_0[0:8]:       NetworkEthereum,
	_NetworkLowerName_0[0:8]:  NetworkEthereum,
	_NetworkName_1[0:8]:       NetworkOptimism,
	_NetworkLowerName_1[0:8]:  NetworkOptimism,
	_NetworkName_2[0:3]:       NetworkBSC,
	_NetworkLowerName_2[0:3]:  NetworkBSC,
	_NetworkName_3[0:16]:      NetworkEthereumClassic,
	_NetworkLowerName_3[0:16]: NetworkEthereumClassic,
	_NetworkName_4[0:7]:       NetworkPolygon,
	_NetworkLowerName_4[0:7]:  NetworkPolygon,
	_NetworkName_5[0:12]:      NetworkArbitrumOne,
	_NetworkLowerName_5[0:12]: NetworkArbitrumOne,
}

var _NetworkNames = []string{
	_NetworkName_0[0:8],
	_NetworkName_1[0:8],
	_NetworkName_2[0:3],
	_NetworkName_3[0:16],
	_NetworkName_4[0:7],
	_NetworkName_5[0:12],
}

// NetworkString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NetworkString(s string) (Network, error) {
	if val, ok := _NetworkNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NetworkNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Network values", s)
}

// NetworkValues returns all values of the enum
func NetworkValues() []Network {
	return _NetworkValues
}

// NetworkStrings returns a slice of all String values of the enum
func NetworkStrings() []string {
	strs := make([]string, len(_NetworkNames))
	copy(strs, _NetworkNames)
	return strs
}

// IsANetwork returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Network) IsANetwork() bool {
	for _, v := range _NetworkValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Network
func (i Network) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Network
func (i *Network) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Network should be a string, got %s", data)
	}

	var err error
	*i, err = NetworkString(s)
	return err
}
